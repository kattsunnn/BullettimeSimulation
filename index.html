<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>ğŸ¾ ãƒ†ãƒ‹ã‚¹ã‚³ãƒ¼ãƒˆ3D ãƒãƒ¬ãƒƒãƒˆã‚¿ã‚¤ãƒ æ˜ åƒ</title>
  <style>
    body { 
      margin: 0; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
    }
    canvas { 
      display: block; 
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
    
    /* ã‚«ãƒ¡ãƒ©æƒ…å ±ãƒ‘ãƒãƒ« */
    .camera-info {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 14px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      z-index: 1000;
    }
    
    .camera-info h3 {
      margin: 0 0 10px 0;
      color: #FF6B35;
    }
    
    .camera-info .current-camera {
      font-size: 18px;
      color: #4CAF50;
      font-weight: bold;
    }
    
    /* æ“ä½œèª¬æ˜ãƒ‘ãƒãƒ« */
    .controls-info {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 14px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      z-index: 1000;
    }
    
    .controls-info h3 {
      margin: 0 0 10px 0;
      color: #4CAF50;
    }
    
    .controls-info ul {
      margin: 0;
      padding-left: 20px;
    }
    
    .controls-info li {
      margin: 5px 0;
    }
    
    /* é¸æ‰‹æƒ…å ±ãƒ‘ãƒãƒ« */
    .player-info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 14px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      z-index: 1000;
    }
    
    .player-info h3 {
      margin: 0 0 10px 0;
      color: #FF6B35;
    }
    
    .player-info .player {
      margin: 8px 0;
      padding: 5px;
      border-radius: 5px;
    }
    
    .player.player1 {
      background-color: rgba(59, 130, 246, 0.3);
    }
    
    .player.player2 {
      background-color: rgba(239, 68, 68, 0.3);
    }
    
    /* ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ */
    .progress-bar {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 20px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid #4CAF50;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #45a049);
      width: 0%;
      transition: width 0.1s ease;
    }
  </style>
  
  <!-- ES Modulesäº’æ›æ€§ã®ãŸã‚ã®Polyfillï¼ˆå¤ã„ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œï¼‰ -->
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  
  <!-- Import Maps - ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«èª­ã¿è¾¼ã¿ã‚’ç°¡å˜ã«ã™ã‚‹ -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "three/": "https://unpkg.com/three@0.158.0/"
    }
  }
  </script>
</head>
<body>
  <!-- ã‚«ãƒ¡ãƒ©æƒ…å ±ãƒ‘ãƒãƒ« -->
  <div class="camera-info">
    <h3>ğŸ“¹ ãƒãƒ¬ãƒƒãƒˆã‚¿ã‚¤ãƒ </h3>
    <div class="current-camera" id="currentCamera">ã‚«ãƒ¡ãƒ© 1 / 12</div>
    <div>æ‰‹å‹•åˆ¶å¾¡ãƒ¢ãƒ¼ãƒ‰</div>
    <div id="cameraDetails" style="margin-top: 8px; font-size: 12px; opacity: 0.8;">
      è·é›¢: -- m | FOV: --Â°
    </div>
  </div>
  
  <!-- æ“ä½œèª¬æ˜ãƒ‘ãƒãƒ« -->
  <div class="controls-info">
    <h3>ğŸ® æ“ä½œæ–¹æ³•</h3>
    <ul>
      <li><strong>â†â†’:</strong> ã‚«ãƒ¡ãƒ©åˆ‡æ›¿</li>
      <li><strong>R:</strong> æœ€åˆã®ã‚«ãƒ¡ãƒ©ã«ãƒªã‚»ãƒƒãƒˆ</li>
      <li><strong>æ•°å­—1-9:</strong> ç›´æ¥ã‚«ãƒ¡ãƒ©é¸æŠ</li>
      <li><strong>P:</strong> é…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ‡æ›¿</li>
    </ul>
    <div style="margin-top: 10px; font-size: 12px; opacity: 0.8;">
      ğŸ“ è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°: è·é›¢ã«å¿œã˜ã¦FOVèª¿æ•´
    </div>
  </div>
  
  <!-- ã‚«ãƒ¡ãƒ©é…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠãƒ‘ãƒãƒ« -->
  <div class="pattern-selector" style="
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 15px 20px;
    border-radius: 10px;
    font-size: 14px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    z-index: 1000;
  ">
    <h3 style="margin: 0 0 10px 0; color: #FF6B35;">ğŸ“ é…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³</h3>
    <div id="currentPattern" style="font-size: 16px; color: #4CAF50; font-weight: bold;">ãƒ‘ã‚¿ãƒ¼ãƒ³3: ä½å¯†åº¦é…ç½® (12å°)</div>
    <div id="currentSpacing" style="margin-top: 8px; font-size: 12px; opacity: 0.8;">é–“éš”: 3.0m</div>
  </div>
  
  <!-- é¸æ‰‹æƒ…å ±ãƒ‘ãƒãƒ« -->
  <div class="player-info">
    <h3>ğŸ¾ ãƒ†ãƒ‹ã‚¹é¸æ‰‹</h3>
    <div class="player player1">ğŸ”µ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ï¼‰</div>
    <div class="player player2">ğŸ”´ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2</div>
  </div>
  
  <!-- ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ -->
  <div class="progress-bar">
    <div class="progress-fill" id="progressFill"></div>
  </div>
  
  <canvas id="c"></canvas>

<script type="module">
  // ===========================
  // ğŸ¾ Three.js & GLTFLoader ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
  // ===========================
  
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

  console.log('ğŸš€ ãƒãƒ¬ãƒƒãƒˆã‚¿ã‚¤ãƒ æ˜ åƒã‚·ã‚¹ãƒ†ãƒ èµ·å‹•');
  console.log('ğŸ“¦ Three.js version:', THREE.REVISION);

  // ===========================
  // ğŸ¨ ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼è¨­å®š
  // ===========================
  
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
    alpha: true,
    powerPreference: 'high-performance'
  });
  
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  // ===========================
  // ğŸŒ ã‚·ãƒ¼ãƒ³æ§‹ç¯‰
  // ===========================
  
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

  // ===========================
  // ğŸ¾ ITFè¦æ ¼æº–æ‹ ãƒ†ãƒ‹ã‚¹ã‚³ãƒ¼ãƒˆæ§‹ç¯‰
  // ===========================
  
  function createTennisCourt() {
    const courtGroup = new THREE.Group();

    const COURT_LENGTH = 23.77;
    const COURT_WIDTH_DOUBLES = 10.97;
    const COURT_WIDTH_SINGLES = 8.23;
    const SERVICE_LENGTH = 6.40;
    const NET_HEIGHT = 0.914;

    // ã‚³ãƒ¼ãƒˆé¢ï¼ˆç·‘è‰²ï¼‰
    const courtGeometry = new THREE.PlaneGeometry(COURT_WIDTH_DOUBLES, COURT_LENGTH);
    const courtMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
    const court = new THREE.Mesh(courtGeometry, courtMaterial);
    court.rotation.x = -Math.PI / 2;
    court.receiveShadow = true;
    courtGroup.add(court);

    // ãƒ©ã‚¤ãƒ³ã®ä½œæˆé–¢æ•°
    function createLine(width, length, x, z) {
      const lineGeometry = new THREE.PlaneGeometry(width, length);
      const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const line = new THREE.Mesh(lineGeometry, lineMaterial);
      line.rotation.x = -Math.PI / 2;
      line.position.set(x, 0.001, z);
      line.receiveShadow = true;
      return line;
    }

    // ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ï¼ˆä¸Šä¸‹ï¼‰
    courtGroup.add(createLine(COURT_WIDTH_DOUBLES, 0.05, 0, COURT_LENGTH / 2));
    courtGroup.add(createLine(COURT_WIDTH_DOUBLES, 0.05, 0, -COURT_LENGTH / 2));

    // ã‚µã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆãƒ€ãƒ–ãƒ«ã‚¹ï¼‰
    courtGroup.add(createLine(0.05, COURT_LENGTH, COURT_WIDTH_DOUBLES / 2, 0));
    courtGroup.add(createLine(0.05, COURT_LENGTH, -COURT_WIDTH_DOUBLES / 2, 0));

    // ã‚µã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆã‚·ãƒ³ã‚°ãƒ«ã‚¹ï¼‰
    courtGroup.add(createLine(0.05, COURT_LENGTH, COURT_WIDTH_SINGLES / 2, 0));
    courtGroup.add(createLine(0.05, COURT_LENGTH, -COURT_WIDTH_SINGLES / 2, 0));

    // ã‚µãƒ¼ãƒ“ã‚¹ãƒ©ã‚¤ãƒ³ï¼ˆä¸Šä¸‹ï¼‰
    courtGroup.add(createLine(COURT_WIDTH_SINGLES, 0.05, 0, SERVICE_LENGTH));
    courtGroup.add(createLine(COURT_WIDTH_SINGLES, 0.05, 0, -SERVICE_LENGTH));

    // ã‚»ãƒ³ã‚¿ãƒ¼ãƒ©ã‚¤ãƒ³
    courtGroup.add(createLine(0.05, SERVICE_LENGTH * 2, 0, 0));

    // ãƒãƒƒãƒˆã®ä½œæˆ
    const netGeometry = new THREE.BoxGeometry(COURT_WIDTH_DOUBLES, NET_HEIGHT, 0.1);
    const netMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
    const net = new THREE.Mesh(netGeometry, netMaterial);
    net.position.set(0, NET_HEIGHT / 2, 0);
    net.castShadow = true;
    net.receiveShadow = true;
    courtGroup.add(net);

    // ã‚»ãƒ³ã‚¿ãƒ¼ãƒãƒ¼ã‚¯
    courtGroup.add(createLine(0.05, 0.10, 0, COURT_LENGTH / 2));
    courtGroup.add(createLine(0.05, 0.10, 0, -COURT_LENGTH / 2));

    return courtGroup;
  }

  // ===========================
  // ğŸ‘¥ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
  // ===========================
  
  const gltfLoader = new GLTFLoader();
  let player1Group = null;
  let player2Group = null;
  
  async function loadPlayerModel(modelUrl, name, position, rotation) {
    const playerGroup = new THREE.Group();
    playerGroup.name = name;
    
    try {
      console.log(`ğŸ”„ ${name}ã®3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿é–‹å§‹`);
      
      const gltf = await new Promise((resolve, reject) => {
        gltfLoader.load(
          modelUrl,
          (gltf) => resolve(gltf),
          (progress) => {
            const percent = (progress.loaded / progress.total * 100).toFixed(1);
            console.log(`ğŸ“¥ ${name}èª­ã¿è¾¼ã¿é€²æ—: ${percent}%`);
          },
          (error) => reject(error)
        );
      });
      
      const model = gltf.scene;
      
      // ãƒ¢ãƒ‡ãƒ«ã®ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´
      const box = new THREE.Box3().setFromObject(model);
      const modelHeight = box.max.y - box.min.y;
      const targetHeight = 1.0;
      const scale = targetHeight / modelHeight;
      model.scale.setScalar(scale);
      
      // å½±ã®è¨­å®š
      model.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      
      playerGroup.add(model);
      
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
      if (gltf.animations && gltf.animations.length > 0) {
        const mixer = new THREE.AnimationMixer(model);
        const action = mixer.clipAction(gltf.animations[0]);
        action.play();
        playerGroup.userData.mixer = mixer;
      }
      
      console.log(`âœ… ${name}ã®3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿æˆåŠŸ!`);
      
    } catch (error) {
      console.warn(`âš ï¸ ${name}ã®3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—:`, error);
      return null;
    }
    
    playerGroup.position.set(position.x, position.y, position.z);
    playerGroup.rotation.y = rotation;
    
    return playerGroup;
  }

  // ãƒ†ãƒ‹ã‚¹ã‚³ãƒ¼ãƒˆã‚’ä½œæˆ
  const tennisCourt = createTennisCourt();
  scene.add(tennisCourt);

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…ç½®
  const playerModels = {
    player1: 'https://threejs.org/examples/models/gltf/Xbot.glb',
    player2: 'https://threejs.org/examples/models/gltf/Xbot.glb'
  };
  
  const animationMixers = [];
  
  async function setupPlayers() {
    try {
      console.log('ğŸ‘¥ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…ç½®é–‹å§‹...');
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹å¯¾è±¡ï¼‰- è‡ªèº«ã®ã‚³ãƒ¼ãƒˆä¸­å¤®
      player1Group = await loadPlayerModel(
        playerModels.player1,
        'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1',
        { x: 0, y: 0, z: -5.9 },
        0
      );
      
      if (player1Group) {
        scene.add(player1Group);
        if (player1Group.userData.mixer) {
          animationMixers.push(player1Group.userData.mixer);
        }
      }
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2 - è‡ªèº«ã®ã‚³ãƒ¼ãƒˆä¸­å¤®
      player2Group = await loadPlayerModel(
        playerModels.player2,
        'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2',
        { x: 0, y: 0, z: 5.9 },
        Math.PI
      );
      
      if (player2Group) {
        scene.add(player2Group);
        if (player2Group.userData.mixer) {
          animationMixers.push(player2Group.userData.mixer);
        }
      }
      
      // ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼èª­ã¿è¾¼ã¿å¾Œï¼‰
      setupCameraSystem();
      updateCameraUI(); // åˆæœŸUIè¨­å®š
      
      console.log('âœ… ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…ç½®å®Œäº†!');
      
    } catch (error) {
      console.error('âŒ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…ç½®ã‚¨ãƒ©ãƒ¼:', error);
    }
  }

  // ===========================
  // ğŸ“¹ ãƒãƒ¬ãƒƒãƒˆã‚¿ã‚¤ãƒ ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ 
  // ===========================
  
  let cameras = [];
  let currentCameraIndex = 0;
  let currentCameraPattern = 3; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯3.0mé–“éš”ï¼ˆ12å°ï¼‰
  
  // 3ã¤ã®ã‚«ãƒ¡ãƒ©é…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³
  const cameraPatterns = {
    1: { // 0.75mé–“éš” - 47å°ï¼ˆé«˜å¯†åº¦ï¼‰
      spacing: '0.75m',
      description: 'é«˜å¯†åº¦é…ç½®',
      positions: [
        { x: 5.485, y: 0.0, z: 0.97 }, { x: 5.485, y: 0.75, z: 0.97 }, { x: 5.485, y: 1.5, z: 0.97 },
        { x: 5.485, y: 2.25, z: 0.97 }, { x: 5.485, y: 3.0, z: 0.97 }, { x: 5.485, y: 3.75, z: 0.97 },
        { x: 5.485, y: 4.5, z: 0.97 }, { x: 5.485, y: 5.25, z: 0.97 }, { x: 5.485, y: 6.0, z: 0.97 },
        { x: 5.485, y: 6.75, z: 0.97 }, { x: 5.485, y: 7.5, z: 0.97 }, { x: 5.485, y: 8.25, z: 0.97 },
        { x: 5.485, y: 9.0, z: 0.97 }, { x: 5.485, y: 9.75, z: 0.97 }, { x: 5.485, y: 10.5, z: 0.97 },
        { x: 5.485, y: 11.25, z: 0.97 }, { x: 5.37, y: 11.885, z: 0.97 }, { x: 4.62, y: 11.885, z: 0.97 },
        { x: 3.87, y: 11.885, z: 0.97 }, { x: 3.12, y: 11.885, z: 0.97 }, { x: 2.37, y: 11.885, z: 0.97 },
        { x: 1.62, y: 11.885, z: 0.97 }, { x: 0.87, y: 11.885, z: 0.97 }, { x: 0.12, y: 11.885, z: 0.97 },
        { x: -0.63, y: 11.885, z: 0.97 }, { x: -1.38, y: 11.885, z: 0.97 }, { x: -2.13, y: 11.885, z: 0.97 },
        { x: -2.88, y: 11.885, z: 0.97 }, { x: -3.63, y: 11.885, z: 0.97 }, { x: -4.38, y: 11.885, z: 0.97 },
        { x: -5.13, y: 11.885, z: 0.97 }, { x: -5.485, y: 11.49, z: 0.97 }, { x: -5.485, y: 10.74, z: 0.97 },
        { x: -5.485, y: 9.99, z: 0.97 }, { x: -5.485, y: 9.24, z: 0.97 }, { x: -5.485, y: 8.49, z: 0.97 },
        { x: -5.485, y: 7.74, z: 0.97 }, { x: -5.485, y: 6.99, z: 0.97 }, { x: -5.485, y: 6.24, z: 0.97 },
        { x: -5.485, y: 5.49, z: 0.97 }, { x: -5.485, y: 4.74, z: 0.97 }, { x: -5.485, y: 3.99, z: 0.97 },
        { x: -5.485, y: 3.24, z: 0.97 }, { x: -5.485, y: 2.49, z: 0.97 }, { x: -5.485, y: 1.74, z: 0.97 },
        { x: -5.485, y: 0.99, z: 0.97 }, { x: -5.485, y: 0.24, z: 0.97 }
      ]
    },
    2: { // 1.5mé–“éš” - 24å°ï¼ˆä¸­å¯†åº¦ï¼‰
      spacing: '1.5m',
      description: 'ä¸­å¯†åº¦é…ç½®',
      positions: [
        { x: 5.485, y: 0.0, z: 0.97 }, { x: 5.485, y: 1.5, z: 0.97 }, { x: 5.485, y: 3.0, z: 0.97 },
        { x: 5.485, y: 4.5, z: 0.97 }, { x: 5.485, y: 6.0, z: 0.97 }, { x: 5.485, y: 7.5, z: 0.97 },
        { x: 5.485, y: 9.0, z: 0.97 }, { x: 5.485, y: 10.5, z: 0.97 }, { x: 5.37, y: 11.885, z: 0.97 },
        { x: 3.87, y: 11.885, z: 0.97 }, { x: 2.37, y: 11.885, z: 0.97 }, { x: 0.87, y: 11.885, z: 0.97 },
        { x: -0.63, y: 11.885, z: 0.97 }, { x: -2.13, y: 11.885, z: 0.97 }, { x: -3.63, y: 11.885, z: 0.97 },
        { x: -5.13, y: 11.885, z: 0.97 }, { x: -5.485, y: 10.74, z: 0.97 }, { x: -5.485, y: 9.24, z: 0.97 },
        { x: -5.485, y: 7.74, z: 0.97 }, { x: -5.485, y: 6.24, z: 0.97 }, { x: -5.485, y: 4.74, z: 0.97 },
        { x: -5.485, y: 3.24, z: 0.97 }, { x: -5.485, y: 1.74, z: 0.97 }, { x: -5.485, y: 0.24, z: 0.97 }
      ]
    },
    3: { // 3.0mé–“éš” - 12å°ï¼ˆä½å¯†åº¦ï¼‰
      spacing: '3.0m',
      description: 'ä½å¯†åº¦é…ç½®',
      positions: [
        { x: 5.485, y: 0.0, z: 0.97 }, { x: 5.485, y: 3.0, z: 0.97 }, { x: 5.485, y: 6.0, z: 0.97 },
        { x: 5.485, y: 9.0, z: 0.97 }, { x: 5.37, y: 11.885, z: 0.97 }, { x: 2.37, y: 11.885, z: 0.97 },
        { x: -0.63, y: 11.885, z: 0.97 }, { x: -3.63, y: 11.885, z: 0.97 }, { x: -5.485, y: 10.74, z: 0.97 },
        { x: -5.485, y: 7.74, z: 0.97 }, { x: -5.485, y: 4.74, z: 0.97 }, { x: -5.485, y: 1.74, z: 0.97 }
      ]
    }
  };
  
  function setupCameraSystem() {
    if (!player1Group) return;
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã®èƒ´ä½“ä½ç½®ã‚’æ³¨è¦–ç‚¹ã«è¨­å®š
    const targetPosition = new THREE.Vector3(0, 1.0, 5.9); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã®èƒ´ä½“é«˜ã•ï¼ˆ1mï¼‰
    
    // ç¾åœ¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰ã‚«ãƒ¡ãƒ©é…ç½®ã‚’å–å¾—
    const pattern = cameraPatterns[currentCameraPattern];
    const cameraPositions = pattern.positions;
    const cameraCount = cameraPositions.length;
    
    cameras = [];
    currentCameraIndex = 0; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
    
    // åŸºæº–è·é›¢ã¨FOVï¼ˆæœ€ã‚‚è¿‘ã„ã‚«ãƒ¡ãƒ©ã‚’åŸºæº–ã¨ã™ã‚‹ï¼‰
    let minDistance = Infinity;
    const cameraData = [];
    
    // å…¨ã‚«ãƒ¡ãƒ©ã®è·é›¢ã‚’è¨ˆç®—
    for (let i = 0; i < cameraCount; i++) {
      const pos = cameraPositions[i];
      const cameraPos = new THREE.Vector3(pos.x, pos.z, pos.y);
      const distance = cameraPos.distanceTo(targetPosition);
      
      cameraData.push({ pos, distance });
      minDistance = Math.min(minDistance, distance);
    }
    
    const baseFOV = 60; // åŸºæº–è¦–é‡è§’
    
    for (let i = 0; i < cameraCount; i++) {
      const { pos, distance } = cameraData[i];
      
      // è·é›¢ã«å¿œã˜ã¦è¦–é‡è§’ã‚’èª¿æ•´ï¼ˆè¿‘ã„ã‚«ãƒ¡ãƒ©ã¯ç‹­ãã€é ã„ã‚«ãƒ¡ãƒ©ã¯åºƒãï¼‰
      const adjustedFOV = baseFOV * (minDistance / distance);
      
      const camera = new THREE.PerspectiveCamera(
        adjustedFOV,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      
      // æŒ‡å®šåº§æ¨™ã«é…ç½®
      camera.position.set(pos.x, pos.z, pos.y); // Three.jsã®yè»¸ã¯é«˜ã•ã€zè»¸ã¯å¥¥è¡Œã
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã®èƒ´ä½“ã‚’è¦‹ã‚‹
      camera.lookAt(targetPosition);
      
      cameras.push({
        camera: camera,
        angle: (i / cameraCount) * Math.PI * 2,
        name: `ã‚«ãƒ¡ãƒ© ${i + 1}`,
        distance: distance,
        fov: adjustedFOV
      });
      
      console.log(`ğŸ“¹ ${cameras[i].name} é…ç½®: (${camera.position.x.toFixed(3)}, ${camera.position.y.toFixed(3)}, ${camera.position.z.toFixed(3)}) è·é›¢: ${distance.toFixed(2)}m FOV: ${adjustedFOV.toFixed(1)}Â°`);
    }
    
    console.log(`ğŸ¬ ãƒãƒ¬ãƒƒãƒˆã‚¿ã‚¤ãƒ ã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†: ${cameraCount}å°ã®ã‚«ãƒ¡ãƒ©ï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³${currentCameraPattern}: ${pattern.description}ï¼‰`);
    updateCameraUI(); // UIæ›´æ–°
  }
  
  function updateCameraUI() {
    if (!cameras.length) return;
    
    // ã‚«ãƒ¡ãƒ©æƒ…å ±æ›´æ–°
    document.getElementById('currentCamera').textContent = 
      `${cameras[currentCameraIndex].name} / ${cameras.length}`;
    
    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼æ›´æ–°
    const progress = ((currentCameraIndex + 1) / cameras.length) * 100;
    document.getElementById('progressFill').style.width = `${progress}%`;
    
    // ãƒ‘ã‚¿ãƒ¼ãƒ³æƒ…å ±æ›´æ–°
    const pattern = cameraPatterns[currentCameraPattern];
    document.getElementById('currentPattern').textContent = 
      `ãƒ‘ã‚¿ãƒ¼ãƒ³${currentCameraPattern}: ${pattern.description} (${cameras.length}å°)`;
    document.getElementById('currentSpacing').textContent = 
      `é–“éš”: ${pattern.spacing}`;
    
    // ã‚«ãƒ¡ãƒ©è©³ç´°æƒ…å ±æ›´æ–°
    const currentCameraData = cameras[currentCameraIndex];
    if (currentCameraData && currentCameraData.distance && currentCameraData.fov) {
      document.getElementById('cameraDetails').textContent = 
        `è·é›¢: ${currentCameraData.distance.toFixed(2)}m | FOV: ${currentCameraData.fov.toFixed(1)}Â°`;
    }
  }
  
  function switchCameraPattern() {
    // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å¾ªç’°åˆ‡ã‚Šæ›¿ãˆ (1 â†’ 2 â†’ 3 â†’ 1)
    currentCameraPattern = (currentCameraPattern % 3) + 1;
    console.log(`ğŸ”„ ã‚«ãƒ¡ãƒ©ãƒ‘ã‚¿ãƒ¼ãƒ³å¤‰æ›´: ãƒ‘ã‚¿ãƒ¼ãƒ³${currentCameraPattern}`);
    
    // ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ ã‚’å†æ§‹ç¯‰
    setupCameraSystem();
  }
  
  function getCurrentCamera() {
    return cameras.length ? cameras[currentCameraIndex].camera : null;
  }

  // ===========================
  // ğŸ’¡ ç…§æ˜è¨­å®š
  // ===========================
  
  // ç’°å¢ƒå…‰
  const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
  scene.add(ambientLight);

  // å¤ªé™½å…‰ï¼ˆå½±ã‚’ç”Ÿæˆï¼‰
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(10, 20, 10);
  directionalLight.castShadow = true;
  
  // å½±ã®å“è³ªè¨­å®š
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 50;
  directionalLight.shadow.camera.left = -15;
  directionalLight.shadow.camera.right = 15;
  directionalLight.shadow.camera.top = 15;
  directionalLight.shadow.camera.bottom = -15;
  
  scene.add(directionalLight);

  // ===========================
  // âŒ¨ï¸ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
  // ===========================
  
  document.addEventListener('keydown', (event) => {
    switch(event.code) {
      case 'ArrowLeft':
        if (cameras.length) {
          currentCameraIndex = (currentCameraIndex - 1 + cameras.length) % cameras.length;
          updateCameraUI();
          console.log(`â¬…ï¸ ${cameras[currentCameraIndex].name}`);
        }
        break;
      case 'ArrowRight':
        if (cameras.length) {
          currentCameraIndex = (currentCameraIndex + 1) % cameras.length;
          updateCameraUI();
          console.log(`â¡ï¸ ${cameras[currentCameraIndex].name}`);
        }
        break;
      case 'KeyR':
        currentCameraIndex = 0;
        updateCameraUI();
        console.log('ğŸ”„ ãƒªã‚»ãƒƒãƒˆ');
        break;
      case 'KeyP':
        switchCameraPattern();
        break;
      case 'Digit1': case 'Digit2': case 'Digit3':
      case 'Digit4': case 'Digit5': case 'Digit6':
      case 'Digit7': case 'Digit8': case 'Digit9':
        const num = parseInt(event.code.slice(-1)) - 1;
        if (num < cameras.length) {
          currentCameraIndex = num;
          updateCameraUI();
          console.log(`ğŸ”¢ ${cameras[currentCameraIndex].name}`);
        }
        break;
    }
  });

  // ===========================
  // ğŸ”„ ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ
  // ===========================
  
  function handleResize() {
    cameras.forEach(camData => {
      camData.camera.aspect = window.innerWidth / window.innerHeight;
      camData.camera.updateProjectionMatrix();
    });
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    console.log(`ğŸ“± ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ: ${window.innerWidth}x${window.innerHeight}`);
  }
  
  window.addEventListener('resize', handleResize);

  // ===========================
  // ğŸ¬ ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
  // ===========================
  
  let clock = new THREE.Clock();
  
  function animate(timestamp) {
    const deltaTime = clock.getDelta();
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
    animationMixers.forEach(mixer => {
      mixer.update(deltaTime);
    });
    
    // ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ ã¯æ‰‹å‹•åˆ¶å¾¡ã®ã¿
    
    // ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©ã§æç”»
    const activeCamera = getCurrentCamera();
    if (activeCamera) {
      renderer.render(scene, activeCamera);
    }
    
    requestAnimationFrame(animate);
  }

  // ===========================
  // ğŸš€ ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•
  // ===========================
  
  console.log('ğŸ¾ ãƒãƒ¬ãƒƒãƒˆã‚¿ã‚¤ãƒ ãƒ†ãƒ‹ã‚¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•!');
  setupPlayers();
  animate();
</script>
</body>
</html>