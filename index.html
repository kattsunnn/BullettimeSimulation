<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>🎾 テニスコート3D バレットタイム映像</title>
  <style>
    body { 
      margin: 0; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
    }
    canvas { 
      display: block; 
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
    
    /* カメラ情報パネル */
    .camera-info {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 14px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      z-index: 1000;
    }
    
    .camera-info h3 {
      margin: 0 0 10px 0;
      color: #FF6B35;
    }
    
    .camera-info .current-camera {
      font-size: 18px;
      color: #4CAF50;
      font-weight: bold;
    }
    
    /* 操作説明パネル */
    .controls-info {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 14px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      z-index: 1000;
    }
    
    .controls-info h3 {
      margin: 0 0 10px 0;
      color: #4CAF50;
    }
    
    .controls-info ul {
      margin: 0;
      padding-left: 20px;
    }
    
    .controls-info li {
      margin: 5px 0;
    }
    
    /* 選手情報パネル */
    .player-info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 14px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      z-index: 1000;
    }
    
    .player-info h3 {
      margin: 0 0 10px 0;
      color: #FF6B35;
    }
    
    .player-info .player {
      margin: 8px 0;
      padding: 5px;
      border-radius: 5px;
    }
    
    .player.player1 {
      background-color: rgba(59, 130, 246, 0.3);
    }
    
    .player.player2 {
      background-color: rgba(239, 68, 68, 0.3);
    }
    
    /* プログレスバー */
    .progress-bar {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 20px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid #4CAF50;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #45a049);
      width: 0%;
      transition: width 0.1s ease;
    }
  </style>
  
  <!-- ES Modules互換性のためのPolyfill（古いブラウザ対応） -->
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  
  <!-- Import Maps - モジュール読み込みを簡単にする -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "three/": "https://unpkg.com/three@0.158.0/"
    }
  }
  </script>
</head>
<body>
  <!-- カメラ情報パネル -->
  <div class="camera-info">
    <h3>📹 バレットタイム</h3>
    <div class="current-camera" id="currentCamera">カメラ 1 / 12</div>
    <div>手動制御モード</div>
    <div id="cameraDetails" style="margin-top: 8px; font-size: 12px; opacity: 0.8;">
      距離: -- m | FOV: --°
    </div>
  </div>
  
  <!-- 操作説明パネル -->
  <div class="controls-info">
    <h3>🎮 操作方法</h3>
    <ul>
      <li><strong>←→:</strong> カメラ切替</li>
      <li><strong>R:</strong> 最初のカメラにリセット</li>
      <li><strong>数字1-9:</strong> 直接カメラ選択</li>
      <li><strong>P:</strong> 配置パターン切替</li>
    </ul>
    <div style="margin-top: 10px; font-size: 12px; opacity: 0.8;">
      📐 自動スケーリング: 距離に応じてFOV調整
    </div>
  </div>
  
  <!-- カメラ配置パターン選択パネル -->
  <div class="pattern-selector" style="
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 15px 20px;
    border-radius: 10px;
    font-size: 14px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    z-index: 1000;
  ">
    <h3 style="margin: 0 0 10px 0; color: #FF6B35;">📐 配置パターン</h3>
    <div id="currentPattern" style="font-size: 16px; color: #4CAF50; font-weight: bold;">パターン3: 低密度配置 (12台)</div>
    <div id="currentSpacing" style="margin-top: 8px; font-size: 12px; opacity: 0.8;">間隔: 3.0m</div>
  </div>
  
  <!-- 選手情報パネル -->
  <div class="player-info">
    <h3>🎾 テニス選手</h3>
    <div class="player player1">🔵 プレイヤー1（フォーカス）</div>
    <div class="player player2">🔴 プレイヤー2</div>
  </div>
  
  <!-- プログレスバー -->
  <div class="progress-bar">
    <div class="progress-fill" id="progressFill"></div>
  </div>
  
  <canvas id="c"></canvas>

<script type="module">
  // ===========================
  // 🎾 Three.js & GLTFLoader インポート
  // ===========================
  
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

  console.log('🚀 バレットタイム映像システム起動');
  console.log('📦 Three.js version:', THREE.REVISION);

  // ===========================
  // 🎨 レンダラー設定
  // ===========================
  
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
    alpha: true,
    powerPreference: 'high-performance'
  });
  
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  // ===========================
  // 🌍 シーン構築
  // ===========================
  
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

  // ===========================
  // 🎾 ITF規格準拠テニスコート構築
  // ===========================
  
  function createTennisCourt() {
    const courtGroup = new THREE.Group();

    const COURT_LENGTH = 23.77;
    const COURT_WIDTH_DOUBLES = 10.97;
    const COURT_WIDTH_SINGLES = 8.23;
    const SERVICE_LENGTH = 6.40;
    const NET_HEIGHT = 0.914;

    // コート面（緑色）
    const courtGeometry = new THREE.PlaneGeometry(COURT_WIDTH_DOUBLES, COURT_LENGTH);
    const courtMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
    const court = new THREE.Mesh(courtGeometry, courtMaterial);
    court.rotation.x = -Math.PI / 2;
    court.receiveShadow = true;
    courtGroup.add(court);

    // ラインの作成関数
    function createLine(width, length, x, z) {
      const lineGeometry = new THREE.PlaneGeometry(width, length);
      const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const line = new THREE.Mesh(lineGeometry, lineMaterial);
      line.rotation.x = -Math.PI / 2;
      line.position.set(x, 0.001, z);
      line.receiveShadow = true;
      return line;
    }

    // ベースライン（上下）
    courtGroup.add(createLine(COURT_WIDTH_DOUBLES, 0.05, 0, COURT_LENGTH / 2));
    courtGroup.add(createLine(COURT_WIDTH_DOUBLES, 0.05, 0, -COURT_LENGTH / 2));

    // サイドライン（ダブルス）
    courtGroup.add(createLine(0.05, COURT_LENGTH, COURT_WIDTH_DOUBLES / 2, 0));
    courtGroup.add(createLine(0.05, COURT_LENGTH, -COURT_WIDTH_DOUBLES / 2, 0));

    // サイドライン（シングルス）
    courtGroup.add(createLine(0.05, COURT_LENGTH, COURT_WIDTH_SINGLES / 2, 0));
    courtGroup.add(createLine(0.05, COURT_LENGTH, -COURT_WIDTH_SINGLES / 2, 0));

    // サービスライン（上下）
    courtGroup.add(createLine(COURT_WIDTH_SINGLES, 0.05, 0, SERVICE_LENGTH));
    courtGroup.add(createLine(COURT_WIDTH_SINGLES, 0.05, 0, -SERVICE_LENGTH));

    // センターライン
    courtGroup.add(createLine(0.05, SERVICE_LENGTH * 2, 0, 0));

    // ネットの作成
    const netGeometry = new THREE.BoxGeometry(COURT_WIDTH_DOUBLES, NET_HEIGHT, 0.1);
    const netMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
    const net = new THREE.Mesh(netGeometry, netMaterial);
    net.position.set(0, NET_HEIGHT / 2, 0);
    net.castShadow = true;
    net.receiveShadow = true;
    courtGroup.add(net);

    // センターマーク
    courtGroup.add(createLine(0.05, 0.10, 0, COURT_LENGTH / 2));
    courtGroup.add(createLine(0.05, 0.10, 0, -COURT_LENGTH / 2));

    return courtGroup;
  }

  // ===========================
  // 👥 プレイヤー管理システム
  // ===========================
  
  const gltfLoader = new GLTFLoader();
  let player1Group = null;
  let player2Group = null;
  
  async function loadPlayerModel(modelUrl, name, position, rotation) {
    const playerGroup = new THREE.Group();
    playerGroup.name = name;
    
    try {
      console.log(`🔄 ${name}の3Dモデル読み込み開始`);
      
      const gltf = await new Promise((resolve, reject) => {
        gltfLoader.load(
          modelUrl,
          (gltf) => resolve(gltf),
          (progress) => {
            const percent = (progress.loaded / progress.total * 100).toFixed(1);
            console.log(`📥 ${name}読み込み進捗: ${percent}%`);
          },
          (error) => reject(error)
        );
      });
      
      const model = gltf.scene;
      
      // モデルのスケール調整
      const box = new THREE.Box3().setFromObject(model);
      const modelHeight = box.max.y - box.min.y;
      const targetHeight = 1.0;
      const scale = targetHeight / modelHeight;
      model.scale.setScalar(scale);
      
      // 影の設定
      model.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      
      playerGroup.add(model);
      
      // アニメーション設定
      if (gltf.animations && gltf.animations.length > 0) {
        const mixer = new THREE.AnimationMixer(model);
        const action = mixer.clipAction(gltf.animations[0]);
        action.play();
        playerGroup.userData.mixer = mixer;
      }
      
      console.log(`✅ ${name}の3Dモデル読み込み成功!`);
      
    } catch (error) {
      console.warn(`⚠️ ${name}の3Dモデル読み込み失敗:`, error);
      return null;
    }
    
    playerGroup.position.set(position.x, position.y, position.z);
    playerGroup.rotation.y = rotation;
    
    return playerGroup;
  }

  // テニスコートを作成
  const tennisCourt = createTennisCourt();
  scene.add(tennisCourt);

  // プレイヤー配置
  const playerModels = {
    player1: 'https://threejs.org/examples/models/gltf/Xbot.glb',
    player2: 'https://threejs.org/examples/models/gltf/Xbot.glb'
  };
  
  const animationMixers = [];
  
  async function setupPlayers() {
    try {
      console.log('👥 プレイヤー配置開始...');
      
      // プレイヤー1（フォーカス対象）- 自身のコート中央
      player1Group = await loadPlayerModel(
        playerModels.player1,
        'プレイヤー1',
        { x: 0, y: 0, z: -5.9 },
        0
      );
      
      if (player1Group) {
        scene.add(player1Group);
        if (player1Group.userData.mixer) {
          animationMixers.push(player1Group.userData.mixer);
        }
      }
      
      // プレイヤー2 - 自身のコート中央
      player2Group = await loadPlayerModel(
        playerModels.player2,
        'プレイヤー2',
        { x: 0, y: 0, z: 5.9 },
        Math.PI
      );
      
      if (player2Group) {
        scene.add(player2Group);
        if (player2Group.userData.mixer) {
          animationMixers.push(player2Group.userData.mixer);
        }
      }
      
      // カメラシステム初期化（プレイヤー読み込み後）
      setupCameraSystem();
      updateCameraUI(); // 初期UI設定
      
      console.log('✅ プレイヤー配置完了!');
      
    } catch (error) {
      console.error('❌ プレイヤー配置エラー:', error);
    }
  }

  // ===========================
  // 📹 バレットタイムカメラシステム
  // ===========================
  
  let cameras = [];
  let currentCameraIndex = 0;
  let currentCameraPattern = 3; // デフォルトは3.0m間隔（12台）
  
  // 3つのカメラ配置パターン
  const cameraPatterns = {
    1: { // 0.75m間隔 - 47台（高密度）
      spacing: '0.75m',
      description: '高密度配置',
      positions: [
        { x: 5.485, y: 0.0, z: 0.97 }, { x: 5.485, y: 0.75, z: 0.97 }, { x: 5.485, y: 1.5, z: 0.97 },
        { x: 5.485, y: 2.25, z: 0.97 }, { x: 5.485, y: 3.0, z: 0.97 }, { x: 5.485, y: 3.75, z: 0.97 },
        { x: 5.485, y: 4.5, z: 0.97 }, { x: 5.485, y: 5.25, z: 0.97 }, { x: 5.485, y: 6.0, z: 0.97 },
        { x: 5.485, y: 6.75, z: 0.97 }, { x: 5.485, y: 7.5, z: 0.97 }, { x: 5.485, y: 8.25, z: 0.97 },
        { x: 5.485, y: 9.0, z: 0.97 }, { x: 5.485, y: 9.75, z: 0.97 }, { x: 5.485, y: 10.5, z: 0.97 },
        { x: 5.485, y: 11.25, z: 0.97 }, { x: 5.37, y: 11.885, z: 0.97 }, { x: 4.62, y: 11.885, z: 0.97 },
        { x: 3.87, y: 11.885, z: 0.97 }, { x: 3.12, y: 11.885, z: 0.97 }, { x: 2.37, y: 11.885, z: 0.97 },
        { x: 1.62, y: 11.885, z: 0.97 }, { x: 0.87, y: 11.885, z: 0.97 }, { x: 0.12, y: 11.885, z: 0.97 },
        { x: -0.63, y: 11.885, z: 0.97 }, { x: -1.38, y: 11.885, z: 0.97 }, { x: -2.13, y: 11.885, z: 0.97 },
        { x: -2.88, y: 11.885, z: 0.97 }, { x: -3.63, y: 11.885, z: 0.97 }, { x: -4.38, y: 11.885, z: 0.97 },
        { x: -5.13, y: 11.885, z: 0.97 }, { x: -5.485, y: 11.49, z: 0.97 }, { x: -5.485, y: 10.74, z: 0.97 },
        { x: -5.485, y: 9.99, z: 0.97 }, { x: -5.485, y: 9.24, z: 0.97 }, { x: -5.485, y: 8.49, z: 0.97 },
        { x: -5.485, y: 7.74, z: 0.97 }, { x: -5.485, y: 6.99, z: 0.97 }, { x: -5.485, y: 6.24, z: 0.97 },
        { x: -5.485, y: 5.49, z: 0.97 }, { x: -5.485, y: 4.74, z: 0.97 }, { x: -5.485, y: 3.99, z: 0.97 },
        { x: -5.485, y: 3.24, z: 0.97 }, { x: -5.485, y: 2.49, z: 0.97 }, { x: -5.485, y: 1.74, z: 0.97 },
        { x: -5.485, y: 0.99, z: 0.97 }, { x: -5.485, y: 0.24, z: 0.97 }
      ]
    },
    2: { // 1.5m間隔 - 24台（中密度）
      spacing: '1.5m',
      description: '中密度配置',
      positions: [
        { x: 5.485, y: 0.0, z: 0.97 }, { x: 5.485, y: 1.5, z: 0.97 }, { x: 5.485, y: 3.0, z: 0.97 },
        { x: 5.485, y: 4.5, z: 0.97 }, { x: 5.485, y: 6.0, z: 0.97 }, { x: 5.485, y: 7.5, z: 0.97 },
        { x: 5.485, y: 9.0, z: 0.97 }, { x: 5.485, y: 10.5, z: 0.97 }, { x: 5.37, y: 11.885, z: 0.97 },
        { x: 3.87, y: 11.885, z: 0.97 }, { x: 2.37, y: 11.885, z: 0.97 }, { x: 0.87, y: 11.885, z: 0.97 },
        { x: -0.63, y: 11.885, z: 0.97 }, { x: -2.13, y: 11.885, z: 0.97 }, { x: -3.63, y: 11.885, z: 0.97 },
        { x: -5.13, y: 11.885, z: 0.97 }, { x: -5.485, y: 10.74, z: 0.97 }, { x: -5.485, y: 9.24, z: 0.97 },
        { x: -5.485, y: 7.74, z: 0.97 }, { x: -5.485, y: 6.24, z: 0.97 }, { x: -5.485, y: 4.74, z: 0.97 },
        { x: -5.485, y: 3.24, z: 0.97 }, { x: -5.485, y: 1.74, z: 0.97 }, { x: -5.485, y: 0.24, z: 0.97 }
      ]
    },
    3: { // 3.0m間隔 - 12台（低密度）
      spacing: '3.0m',
      description: '低密度配置',
      positions: [
        { x: 5.485, y: 0.0, z: 0.97 }, { x: 5.485, y: 3.0, z: 0.97 }, { x: 5.485, y: 6.0, z: 0.97 },
        { x: 5.485, y: 9.0, z: 0.97 }, { x: 5.37, y: 11.885, z: 0.97 }, { x: 2.37, y: 11.885, z: 0.97 },
        { x: -0.63, y: 11.885, z: 0.97 }, { x: -3.63, y: 11.885, z: 0.97 }, { x: -5.485, y: 10.74, z: 0.97 },
        { x: -5.485, y: 7.74, z: 0.97 }, { x: -5.485, y: 4.74, z: 0.97 }, { x: -5.485, y: 1.74, z: 0.97 }
      ]
    }
  };
  
  function setupCameraSystem() {
    if (!player1Group) return;
    
    // プレイヤー2の胴体位置を注視点に設定
    const targetPosition = new THREE.Vector3(0, 1.0, 5.9); // プレイヤー2の胴体高さ（1m）
    
    // 現在のパターンからカメラ配置を取得
    const pattern = cameraPatterns[currentCameraPattern];
    const cameraPositions = pattern.positions;
    const cameraCount = cameraPositions.length;
    
    cameras = [];
    currentCameraIndex = 0; // インデックスをリセット
    
    // 基準距離とFOV（最も近いカメラを基準とする）
    let minDistance = Infinity;
    const cameraData = [];
    
    // 全カメラの距離を計算
    for (let i = 0; i < cameraCount; i++) {
      const pos = cameraPositions[i];
      const cameraPos = new THREE.Vector3(pos.x, pos.z, pos.y);
      const distance = cameraPos.distanceTo(targetPosition);
      
      cameraData.push({ pos, distance });
      minDistance = Math.min(minDistance, distance);
    }
    
    const baseFOV = 60; // 基準視野角
    
    for (let i = 0; i < cameraCount; i++) {
      const { pos, distance } = cameraData[i];
      
      // 距離に応じて視野角を調整（近いカメラは狭く、遠いカメラは広く）
      const adjustedFOV = baseFOV * (minDistance / distance);
      
      const camera = new THREE.PerspectiveCamera(
        adjustedFOV,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      
      // 指定座標に配置
      camera.position.set(pos.x, pos.z, pos.y); // Three.jsのy軸は高さ、z軸は奥行き
      
      // プレイヤー2の胴体を見る
      camera.lookAt(targetPosition);
      
      cameras.push({
        camera: camera,
        angle: (i / cameraCount) * Math.PI * 2,
        name: `カメラ ${i + 1}`,
        distance: distance,
        fov: adjustedFOV
      });
      
      console.log(`📹 ${cameras[i].name} 配置: (${camera.position.x.toFixed(3)}, ${camera.position.y.toFixed(3)}, ${camera.position.z.toFixed(3)}) 距離: ${distance.toFixed(2)}m FOV: ${adjustedFOV.toFixed(1)}°`);
    }
    
    console.log(`🎬 バレットタイムシステム準備完了: ${cameraCount}台のカメラ（パターン${currentCameraPattern}: ${pattern.description}）`);
    updateCameraUI(); // UI更新
  }
  
  function updateCameraUI() {
    if (!cameras.length) return;
    
    // カメラ情報更新
    document.getElementById('currentCamera').textContent = 
      `${cameras[currentCameraIndex].name} / ${cameras.length}`;
    
    // プログレスバー更新
    const progress = ((currentCameraIndex + 1) / cameras.length) * 100;
    document.getElementById('progressFill').style.width = `${progress}%`;
    
    // パターン情報更新
    const pattern = cameraPatterns[currentCameraPattern];
    document.getElementById('currentPattern').textContent = 
      `パターン${currentCameraPattern}: ${pattern.description} (${cameras.length}台)`;
    document.getElementById('currentSpacing').textContent = 
      `間隔: ${pattern.spacing}`;
    
    // カメラ詳細情報更新
    const currentCameraData = cameras[currentCameraIndex];
    if (currentCameraData && currentCameraData.distance && currentCameraData.fov) {
      document.getElementById('cameraDetails').textContent = 
        `距離: ${currentCameraData.distance.toFixed(2)}m | FOV: ${currentCameraData.fov.toFixed(1)}°`;
    }
  }
  
  function switchCameraPattern() {
    // パターンを循環切り替え (1 → 2 → 3 → 1)
    currentCameraPattern = (currentCameraPattern % 3) + 1;
    console.log(`🔄 カメラパターン変更: パターン${currentCameraPattern}`);
    
    // カメラシステムを再構築
    setupCameraSystem();
  }
  
  function getCurrentCamera() {
    return cameras.length ? cameras[currentCameraIndex].camera : null;
  }

  // ===========================
  // 💡 照明設定
  // ===========================
  
  // 環境光
  const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
  scene.add(ambientLight);

  // 太陽光（影を生成）
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(10, 20, 10);
  directionalLight.castShadow = true;
  
  // 影の品質設定
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 50;
  directionalLight.shadow.camera.left = -15;
  directionalLight.shadow.camera.right = 15;
  directionalLight.shadow.camera.top = 15;
  directionalLight.shadow.camera.bottom = -15;
  
  scene.add(directionalLight);

  // ===========================
  // ⌨️ キーボード操作
  // ===========================
  
  document.addEventListener('keydown', (event) => {
    switch(event.code) {
      case 'ArrowLeft':
        if (cameras.length) {
          currentCameraIndex = (currentCameraIndex - 1 + cameras.length) % cameras.length;
          updateCameraUI();
          console.log(`⬅️ ${cameras[currentCameraIndex].name}`);
        }
        break;
      case 'ArrowRight':
        if (cameras.length) {
          currentCameraIndex = (currentCameraIndex + 1) % cameras.length;
          updateCameraUI();
          console.log(`➡️ ${cameras[currentCameraIndex].name}`);
        }
        break;
      case 'KeyR':
        currentCameraIndex = 0;
        updateCameraUI();
        console.log('🔄 リセット');
        break;
      case 'KeyP':
        switchCameraPattern();
        break;
      case 'Digit1': case 'Digit2': case 'Digit3':
      case 'Digit4': case 'Digit5': case 'Digit6':
      case 'Digit7': case 'Digit8': case 'Digit9':
        const num = parseInt(event.code.slice(-1)) - 1;
        if (num < cameras.length) {
          currentCameraIndex = num;
          updateCameraUI();
          console.log(`🔢 ${cameras[currentCameraIndex].name}`);
        }
        break;
    }
  });

  // ===========================
  // 🔄 レスポンシブ対応
  // ===========================
  
  function handleResize() {
    cameras.forEach(camData => {
      camData.camera.aspect = window.innerWidth / window.innerHeight;
      camData.camera.updateProjectionMatrix();
    });
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    console.log(`📱 リサイズ対応: ${window.innerWidth}x${window.innerHeight}`);
  }
  
  window.addEventListener('resize', handleResize);

  // ===========================
  // 🎬 メインアニメーションループ
  // ===========================
  
  let clock = new THREE.Clock();
  
  function animate(timestamp) {
    const deltaTime = clock.getDelta();
    
    // プレイヤーアニメーション更新
    animationMixers.forEach(mixer => {
      mixer.update(deltaTime);
    });
    
    // カメラシステムは手動制御のみ
    
    // 現在のカメラで描画
    const activeCamera = getCurrentCamera();
    if (activeCamera) {
      renderer.render(scene, activeCamera);
    }
    
    requestAnimationFrame(animate);
  }

  // ===========================
  // 🚀 アプリケーション起動
  // ===========================
  
  console.log('🎾 バレットタイムテニスシミュレーション起動!');
  setupPlayers();
  animate();
</script>
</body>
</html>